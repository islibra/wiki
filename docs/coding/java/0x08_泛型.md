# 0x08_泛型

对集合的补充, 使集合可以识别元素类型

```java
// 未指定元素类型, 默认Object
List noTypeList = new ArrayList();
noTypeList.add("hello");
noTypeList.add("world");
// 不小心添加Integer
noTypeList.add(3);
for (Object ele : noTypeList) {
    // java.lang.ClassCastException
    LOG.info((String) ele);
}
```

## 一、泛型接口/类

在 **接口/类名后面** 添加类型参数声明部分，如：

```java
// 定义接口时指定形参, 相当于List的子类
public interface List<E> extends Collection<E>
{
    // 在接口里, E可以作为类型使用
    boolean add(E e);
}

public class ArrayList<E> extends AbstractList<E>
        implements List<E>
{}
```

```java
import java.util.logging.Logger;

public class Apple<T> {
    private static final Logger LOG = Logger.getLogger(Apple.class.getName());
    private T info;

    public Apple() {
    }

    public Apple(T info) {
        this.info = info;
    }

    public T getInfo() {
        return info;
    }

    public void setInfo(T info) {
        this.info = info;
    }

    public static void main(String[] args) {
        Apple<String> a1 = new Apple<>("apple");
        LOG.info(a1.getInfo());
        Apple<Integer> a2 = new Apple<>(123);
        LOG.info("a2: " + a2.getInfo());
    }
}
```

```java
// 调用构造器创建对象时自动推断元素类型
List<String> strList = new ArrayList<>();
strList.add("hello");
strList.add("world");
for (String ele : strList) {
    LOG.info(ele);
}
```


## 一、泛型方法

在方法 **返回类型** 之前增加类型参数声明部分，如：

```java
public static <E> void printArray(E[] inputArray)
```

有界的类型参数：

```java
public static <T extends Number> T minimum(T x, T y, T z)

public static <T extends Comparable<T>> T maximum(T x, T y, T z)
```

## 三、类型通配符

```java
public static void getClas(GenericsClassExp<?> clas)
```

通配符上限

```java
public static void getNum(List<? extends Number> num)
```
